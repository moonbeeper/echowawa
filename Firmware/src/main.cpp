#include <Arduino.h>
#include <U8g2lib.h>
#include <Wire.h>
#include <Versatile_RotaryEncoder.h>
#include <AudioTools.h>
#include <BluetoothA2DPSink.h>
#include <Adafruit_NeoPixel.h>

U8G2_SSD1306_128X64_NONAME_1_SW_I2C u8g2(U8G2_R0, 19, 18); // I don't really know if this should be SH1106
static const unsigned char side_lines[] U8X8_PROGMEM = {0x0f};
// static const unsigned char item_outline[] U8X8_PROGMEM = {0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00};
static const unsigned char bluetooth_icon[] U8X8_PROGMEM = {0x04, 0x0d, 0x16, 0x0c, 0x0c, 0x16, 0x0d, 0x04};
static const unsigned char speaker_icon[] U8X8_PROGMEM = {0x48, 0x8c, 0xaf, 0xaf, 0x8c, 0x48};
static const unsigned char X_Icon[] U8X8_PROGMEM = {0x63, 0x36, 0x1c, 0x3e, 0x1c, 0x36, 0x63};
static const unsigned char USB_C_LeftArrow[] U8X8_PROGMEM = {0x7c, 0x3e, 0x82, 0x41, 0x01, 0x80, 0x01, 0x80, 0xfd, 0xbf, 0x01, 0x80, 0x01, 0x80, 0x02, 0x40, 0xfc, 0x3f, 0x00, 0x00, 0x10, 0x02, 0x60, 0x06, 0xc0, 0x0f, 0x00, 0x06, 0x00, 0x02};
static const unsigned char dialog_box_background[] U8X8_PROGMEM = {0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03};
static const unsigned char warning_here[] U8X8_PROGMEM = {0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x18, 0x00, 0x42, 0x00, 0x18, 0xbe, 0x00, 0x99, 0x00, 0x7d, 0xf1, 0x00, 0x99, 0x00, 0x8f, 0xe0, 0x80, 0x18, 0x01, 0x07, 0xf0, 0x80, 0x18, 0x01, 0x0f, 0x00, 0x40, 0x18, 0x02, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x00, 0x20, 0x18, 0x04, 0x00, 0x00, 0x10, 0x18, 0x08, 0x00, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0xe0, 0xff, 0x07, 0x00};
static const unsigned char sad_face[] U8X8_PROGMEM = {0x38, 0x70, 0xfe, 0xf8, 0xfe, 0xf8, 0xfe, 0xf8, 0x3c, 0x70, 0x06, 0x00, 0x83, 0x0f, 0xe0, 0x38, 0x38, 0xe0};
static const unsigned char mini_swap_icon[] U8X8_PROGMEM = {0x0e, 0x11, 0x24, 0x49, 0x12, 0x44, 0x38};
static const unsigned char mini_output_icon[] U8X8_PROGMEM = {0x1e, 0x01, 0x21, 0x7d, 0x21, 0x01, 0x1e};
static const unsigned char alright_here[] U8X8_PROGMEM = {0x18, 0x00, 0x00, 0x04, 0x18, 0xbe, 0x00, 0x00, 0x06, 0x7d, 0xf1, 0x00, 0x00, 0x07, 0x8f, 0xe0, 0x20, 0x80, 0x03, 0x07, 0xf0, 0x60, 0xc0, 0x01, 0x0f, 0x00, 0xe0, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x71, 0x00, 0x00, 0x00, 0x80, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x40, 0x0c, 0x00, 0x00, 0x00, 0x30};

#define NEOPIXEL_CTRL 15
#define NEOPIXEL_COUNT 2
Adafruit_NeoPixel neo_strip(NEOPIXEL_COUNT, NEOPIXEL_CTRL, NEO_GRB + NEO_KHZ800);
void updateNeoStrip();

#define AUX_SENSE 12
#define SWAP_DAC 14
#define SWAP_OUTPUT 13

void checkAUXSense();
unsigned long auxSenseLastChange = 0;
const unsigned auxSenseDelay = 1000;

bool currentDac = false;    // false = little one's DAC, true = Audio Codec
bool currentOutput = false; // false = headphone jack, true = RCA jacks

#define DAC_MUTE 19
#define DAC_DATA 27
#define DAC_BCK 26
#define DAC_LCK 25

I2SStream i2s;
BluetoothA2DPSink a2dp_sink(i2s);

#define ENCODER_A 32
#define ENCODER_B 2
#define ENCODER_SW 34

Versatile_RotaryEncoder *versatile_encoder;
void handleEncoderRotate(int8_t rotation);
void handleEncoderPress();

enum DialogId
{
  NO_DIALOG,
  UNIMPLEMENTED_DIALOG,
  SWAPPED_DIALOG,
  AUTO_SWAPPED_DIALOG,
};
DialogId currentDialog = DialogId::NO_DIALOG;

struct DialogInfo
{
  const char *label;
  const unsigned char *icon; // 40x14
  const bool showSadFace;
};

DialogInfo notImplementedDialog = {"Not Implemented!", warning_here, true};
DialogInfo swappedDialog = {"Swapped!", alright_here, false};
DialogInfo autoSwappedDialog = {"Auto-Swapped to AUX", alright_here, false};

const DialogInfo *getDialog(DialogId id)
{
  switch (id)
  {
  case UNIMPLEMENTED_DIALOG:
    return &notImplementedDialog;
  case SWAPPED_DIALOG:
    return &swappedDialog;
  case AUTO_SWAPPED_DIALOG:
    return &autoSwappedDialog;
  default:
    return nullptr;
  }
};
void drawDialog(const DialogInfo *dialog);
unsigned long dialogLastChange = 0;
unsigned long dialogChangeDelay = 1000;
bool isDialogActive = false;

enum MenuItemId
{
  ITEM_NONE,
  ITEM_BLUETOOTH,
  ITEM_AUX,
  ITEM_SETTINGS,
  ITEM_SWAP_DAC,
  ITEM_SWAP_OUTPUT
};
void setActive(MenuItemId id, bool active);

struct MenuItem
{
  MenuItemId id;
  const char *label;             // max 10 chars or else the text will touch the edges if in special width mode
  const unsigned char *preIcon;  // 7x7
  const unsigned char *postIcon; // 16x15
  void (*callback)();
};
void actionBluetooth();
void actionUsbAux();
void actionSwapDAC();
void actionSwapOutput();
void createItemOutline(int8_t min, int8_t max, int8_t special_max, MenuItem &menu, int8_t radius);

#define MENU_ITEM_OUTLINE_MIN_WIDTH 45
#define MENU_ITEM_OUTLINE_MAX_WIDTH 118
#define MENU_ITEM_OUTLINE_SPECIAL_MAX_WIDTH 89
#define MENU_ITEM_OUTLINE_RADIUS 5

#define MENU_ITEM_COUNT 5
MenuItem menu_items[MENU_ITEM_COUNT] = {
    {ITEM_BLUETOOTH, "Bluetooth", nullptr, nullptr, actionBluetooth},
    {ITEM_AUX, "USB C AUX", nullptr, USB_C_LeftArrow, actionUsbAux},
    {ITEM_SETTINGS, "Settings", X_Icon, nullptr, []() // lambdas are weirdly formatted
     {
       currentDialog = DialogId::UNIMPLEMENTED_DIALOG;
     }},
    {ITEM_SWAP_DAC, "Swap Input", mini_swap_icon, nullptr, actionSwapDAC},
    {ITEM_SWAP_OUTPUT, "Swap Output", mini_output_icon, nullptr, actionSwapOutput}};

const uint8_t yPos[MENU_ITEM_COUNT] = {27, 43, 59};
void drawHeader(bool showAux, bool showBluetooth);

uint8_t shouldRedraw = 1;
int item_selected = 0;
int item_sel_previous;
int item_sel_next;

bool isA2DPActive = false;
bool isAUXActive = false;

void setup()
{
  pinMode(AUX_SENSE, INPUT);
  pinMode(SWAP_DAC, INPUT);
  pinMode(SWAP_OUTPUT, INPUT);
  pinMode(DAC_MUTE, OUTPUT);
  digitalWrite(DAC_MUTE, LOW);    // mute little one's dac
  digitalWrite(SWAP_DAC, LOW);    // default to little one's DAC
  digitalWrite(SWAP_OUTPUT, LOW); // default to headphone jack

  Serial.begin(115200);
  Serial.println("starting up...");

  auto cfg = i2s.defaultConfig();
  cfg.pin_data = DAC_DATA;
  cfg.pin_bck = DAC_BCK;
  cfg.pin_ws = DAC_LCK;
  i2s.begin(cfg);

  digitalWrite(DAC_MUTE, HIGH); // unmute little one's dac

  u8g2.begin();
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);

  versatile_encoder = new Versatile_RotaryEncoder(ENCODER_A, ENCODER_B, ENCODER_SW);
  versatile_encoder->setHandleRotate(handleEncoderRotate);
  versatile_encoder->setHandlePress(handleEncoderPress);

  neo_strip.begin();
  neo_strip.show();

  Serial.println("done");
}

uint32_t activeMenuItems = 0;
// bitwise ops. my favorite.
void toggleActive(uint32_t &flags, uint8_t index)
{
  flags ^= (1 << index);
}

bool isActive(uint32_t flags, uint8_t index)
{
  return (flags & (1 << index)) != 0;
}

// bad. but seems to work with 3 items. dunno if it will work with more.
// nevermind it works with 4-5 items too.
void setActive(MenuItemId id, bool active)
{
  for (int i = 0; i < MENU_ITEM_COUNT; ++i)
  {
    if (menu_items[i].id == id)
    {
      if (active)
        activeMenuItems |= (1 << i);
      else
        activeMenuItems &= ~(1 << i);
      break;
    }
  }
}

void loop()
{
  updateNeoStrip();
  checkAUXSense();

  if (isDialogActive && (millis() - dialogLastChange) > dialogChangeDelay)
  {
    isDialogActive = false;
    currentDialog = NO_DIALOG;
    shouldRedraw = 1;
  }

  if (currentDialog != NO_DIALOG && !isDialogActive)
  {
    isDialogActive = true;
    dialogLastChange = millis();
    shouldRedraw = 1;
    return;
  }

  if (isDialogActive)
  {
    drawDialog(getDialog(currentDialog));
    shouldRedraw = 0;
    return;
  }

  if (versatile_encoder->ReadEncoder())
  {
    shouldRedraw = 1;
  }

  item_sel_previous = item_selected - 1;
  if (item_sel_previous < 0)
  {
    item_sel_previous = MENU_ITEM_COUNT - 1;
  }
  item_sel_next = item_selected + 1;
  if (item_sel_next >= MENU_ITEM_COUNT)
  {
    item_sel_next = 0;
  }

  if (!shouldRedraw)
  {
    return;
  }

  u8g2.firstPage();
  do
  {
    drawHeader(isA2DPActive, isAUXActive);
    u8g2.setFont(u8g2_font_profont17_tr);

    int items[3] = {item_sel_previous, item_selected, item_sel_next};
    for (uint8_t i = 0; i < 3; ++i)
    {
      uint8_t y = yPos[i];
      int idx = items[i];
      MenuItem &menu = menu_items[idx];

      if (menu.preIcon)
      {
        u8g2.drawXBMP(2, y - 9, 7, 7, menu.preIcon);
      }
      else
      {
        if (isActive(activeMenuItems, idx))
        {
          u8g2.drawFilledEllipse(5, y - 6, 3, 3);
        }
        else
        {
          u8g2.drawEllipse(5, y - 6, 3, 3);
        }
      }

      u8g2.drawStr(15, y, menu.label);

      if (menu_items[idx].postIcon)
      {
        uint8_t textWidth = u8g2.getStrWidth(menu.label);
        u8g2.drawXBMP(23 + textWidth, y - 12, 16, 15, menu.postIcon);
      }

      if (i == 1)
      {
        createItemOutline(MENU_ITEM_OUTLINE_MIN_WIDTH, MENU_ITEM_OUTLINE_MAX_WIDTH, MENU_ITEM_OUTLINE_SPECIAL_MAX_WIDTH, menu, MENU_ITEM_OUTLINE_RADIUS);
        // u8g2.drawXBMP(11, 29, 89, 17, item_outline);
      }
    }

    // scroll bar and side lines (or dashes)
    u8g2.drawBox(125, (53 / MENU_ITEM_COUNT * item_selected) + 11, 3, (53 / MENU_ITEM_COUNT));
    u8g2.drawXBMP(122, 46, 4, 1, side_lines);
    u8g2.drawXBMP(122, 30, 4, 1, side_lines);
    u8g2.drawXBMP(122, 14, 4, 1, side_lines);
    u8g2.drawXBMP(122, 61, 4, 1, side_lines);

  } while (u8g2.nextPage());
  shouldRedraw = 0;
}

void handleEncoderRotate(int8_t rotation)
{
  Serial.print("#1 Rotated: ");
  if (rotation > 0)
  {
    Serial.println("Right");
    item_selected = (item_selected + MENU_ITEM_COUNT - 1) % MENU_ITEM_COUNT;
    Serial.println(item_selected);
  }
  else
  {
    Serial.println("Left");
    item_selected = (item_selected + 1) % MENU_ITEM_COUNT;
    Serial.println(item_selected);
  }
}

void handleEncoderPress()
{
  Serial.println("Pressed!");
  toggleActive(activeMenuItems, item_selected);
  if (menu_items[item_selected].callback)
  {
    menu_items[item_selected].callback();
  }
}

void drawHeader(bool showAux, bool showBluetooth)
{
  u8g2.setFont(u8g2_font_haxrcorp4089_tr);
  u8g2.drawStr(3, 10, "echowawa");

  if (showAux)
  {
    u8g2.setFont(u8g2_font_5x8_tr);
    u8g2.drawStr(89, 9, "AUX");
  }

  if (showBluetooth)
  {
    u8g2.drawXBMP(108, 2, 5, 8, bluetooth_icon);
  }

  u8g2.drawXBMP(117, 3, 8, 6, speaker_icon);
  u8g2.drawLine(2, 11, 125, 11);
}

void actionBluetooth()
{
  if (isA2DPActive)
  {
    a2dp_sink.stop();
    isA2DPActive = false;
  }
  else
  {
    if (isAUXActive)
    {
      setActive(ITEM_AUX, false);
      isAUXActive = false;
    }

    a2dp_sink.start("echowawa");
    isA2DPActive = true;
  }

  Serial.println("Bluetooth action!");
}

void actionUsbAux()
{
  if (isAUXActive)
  {
    isAUXActive = false;
  }
  else
  {
    if (isA2DPActive)
    {
      actionBluetooth();
      setActive(ITEM_BLUETOOTH, false);
      isA2DPActive = false;
    }
    isAUXActive = true;
  }

  Serial.println("USB C AUX action!");
}

void drawDialog(const DialogInfo *dialog)
{
  if (!dialog)
    return;

  u8g2.firstPage();
  do
  {
    u8g2.setFontMode(1);
    drawHeader(isA2DPActive, isAUXActive);

    u8g2.drawXBMP(10, 15, 108, 46, dialog_box_background);
    u8g2.drawXBMP(43, 18, 40, 14, dialog->icon);

    uint8_t text_width = u8g2.getStrWidth(dialog->label);
    uint8_t x = 8 + (108 - text_width) / 2;
    u8g2.setFont(u8g2_font_profont12_tr);
    u8g2.drawStr(x, 42, dialog->label);

    if (dialog->showSadFace)
    {
      u8g2.drawXBMP(55, 49, 16, 9, sad_face);
    }
  } while (u8g2.nextPage());
}

void swapDAC()
{
  if (currentDac)
  {
    Serial.println("CODEC -> DAC");
    currentDac = false;
    digitalWrite(DAC_MUTE, HIGH); // unmute little one's dac
    digitalWrite(SWAP_DAC, LOW);
  }
  else
  {
    Serial.println("DAC -> CODEC");
    currentDac = true;
    digitalWrite(DAC_MUTE, LOW); // mute little one's dac
    digitalWrite(SWAP_DAC, HIGH);
  }
}

void swapOutput()
{
  if (currentOutput)
  {
    Serial.println("RCA -> HEADPHONE");
    currentOutput = false;
    digitalWrite(SWAP_OUTPUT, HIGH);
  }
  else
  {
    Serial.println("HEADPHONE -> RCA");
    currentOutput = true;
    digitalWrite(SWAP_OUTPUT, LOW);
  }
}

void actionSwapDAC()
{
  Serial.println("Swapping DACs...");
  swapDAC();
  currentDialog = DialogId::SWAPPED_DIALOG;
}

void actionSwapOutput()
{
  Serial.println("Swapping Outputs...");
  swapOutput();
  currentDialog = DialogId::SWAPPED_DIALOG;
}

void createItemOutline(int8_t min, int8_t max, int8_t special_max, MenuItem &menu, int8_t radius)
{
  uint8_t textWidth = u8g2.getStrWidth(menu.label);
  uint8_t boxWidth;

  if (menu.postIcon)
  {
    boxWidth = special_max;
  }
  else
  {
    boxWidth = textWidth + 7;
    if (boxWidth > max)
    {
      boxWidth = max;
    }
    if (boxWidth < min)
    {
      boxWidth = min;
    }
  }

  u8g2.drawRFrame(11, 29, boxWidth, 17, radius);
}

void checkAUXSense()
{
  if ((millis() - auxSenseLastChange) < auxSenseDelay)
  {
    return; // skip check if not enough time has passed
  }

  auxSenseLastChange = millis();
  if (digitalRead(AUX_SENSE) == LOW)
  {
    Serial.println("AUX is ON!!!!");
    if (!currentDac)
    {
      swapDAC(); // swap to CODEC
      currentDialog = DialogId::AUTO_SWAPPED_DIALOG;
    }
    return;
  }
}

void updateNeoStrip()
{
  if (currentDac)
  {
    neo_strip.setPixelColor(0, 0, 163, 255);
  }
  else
  {
    neo_strip.setPixelColor(0, 255, 164, 0);
  }

  if (currentOutput)
  {
    neo_strip.setPixelColor(1, 0, 255, 16);
  }
  else
  {
    neo_strip.setPixelColor(1, 255, 255, 0);
  }
  neo_strip.show();
}